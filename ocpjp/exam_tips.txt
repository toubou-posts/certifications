CHAPTER 1 Java class design

Calls to the overloaded methods are resolved during compilation.

For primitive method arguments, if a call to an overloaded method is dubious, the code won't compile.

When the Java compiler differentiates methods, it doesn't consider their return types. So you can't define overloaded methods with the same parameter list and different return types.

When the Java compiler differentiates methods, it doesn't consider their return types. So you can't define overloaded methods with the same parameter list and different return types.

overloaded constructors are invoked by using the keyword this

when you invoke an overloaded constructor using the keyword this, it must be the first statement in your constructor

If a parent or child class defines static initializer block(s), they execute before all parent and child class constructors and instance initializers—first for the parent and then for the child class.

An overriding method can throw any unchecked exception (RuntimeException or Error) even if the overridden method doesn’t. The unchecked exceptions aren't part of the method signature and aren’t checked by the compiler.

It’s the reference variable type that dictates which overloaded method will be chosen. This choice is made at compilation time.

When a class extends another class, it can overload, override, or hide its base class methods. A class can’t override or hide its own methods—it can only overload its own methods.

Constructors can’t be overridden because a base class constructor isn’t inherited by a derived class.

Read the questions on method hashCode() carefully. You might be questioned on incorrect, inappropriate, or inefficient overriding of hashCode().

In the absence of explicit casting, you’ll never get ClassCast-Exception—a RuntimeException.

CHAPTER 2
An abstract method can’t be defined in a concrete class. It can be defined in an abstract class only.

Abstract classes make a point loud and clear: they force the concrete derived classes to implement a base class’s abstract methods, in their own unique manner.

A final class can’t be extended.

Nonabstract classes cannot define abstract methods.

Unlike instance variables, which are initialized for each instance, static class variables are initialized only once, when they are loaded into memory.

The static methods can’t access nonstatic fields or nonstatic methods.

A static method is used to manipulate static class variables or to define utility methods. A utility method may or may not accept method parameters.

If a class defines multiple initializer blocks, they execute in the order of their appearance in a class.

If a static or instance variable is marked final, it must be initialized, or the code won’t compile.